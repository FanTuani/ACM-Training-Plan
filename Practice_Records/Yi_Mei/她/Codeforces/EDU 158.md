# EDU 158



## D.

### 题目：

小V遇到了 n 个怪物排成一排，每一个怪物的血量为 ai。小V决定用魔法消灭它们。在施展魔法时，小V会先选择一个怪物所在的位置 ii ，作为这个魔法直接攻击的怪物。然后，他会选择魔法的威力 x 。然而，这种魔法十分特殊，会以一定顺序攻击这 n 个怪物，第 i 个受攻击怪物会受到 x − i + 1点的伤害。具体来说，这个魔法每次会随机选择一个与被这次魔法攻击过的怪物相邻且没有被攻击的怪物作为对象施展一次攻击。小V对自己的实力很自信，所以他想知道在他能随意选择第一个攻击位置 i 的情况下，最小要用多少的威力 x 使得无论魔法沿什么顺序攻击都能杀死所有的怪物。

### 思路：

我们考虑令 i 为起点，那么在 i 左边的位置 j 最坏情况需要以 a[j] + n - j 为开头，在 i 右边的位置 k 最坏情况需要以 a[k] + k - 1为开头，那么如果以 i 为起点，需要的 x 为 a[i]、前缀的最坏情况的最大值、后缀最坏情况的最大值中的最大值。又由于第一步是最优策略，那么我们只需以 1 ~ n 为起点需要的 x 中的最小值即可。

### trick：

题目核心是先假设出初始情况，然后再划分求值范围，分类讨论划分后的各个求值范围再结合起来求值。

```cpp
void Accepted()
{
    int n; cin >> n;
    vector<int> a(n + 10), pre(n + 10), suf(n + 10);
    pre[0] = suf[n + 1] = 0;
    for (int i = 1; i <= n; ++ i) cin >> a[i];
    for (int i = 1; i <= n; ++ i)
    {
        pre[i] = max(pre[i - 1], a[i] + n - i);
    }
    for (int i = n; i >= 1; -- i)
    {
        suf[i] = max(suf[i + 1], a[i] + i - 1);
    }
    int ans = INF;
    for (int i = 1; i <= n; ++ i)
    {
        ans = min(ans, max({pre[i - 1], a[i], suf[i + 1]}));
    }
    cout << ans << "\n";
}
```



## E.https://www.luogu.com.cn/problem/CF1901E （树形DP）
