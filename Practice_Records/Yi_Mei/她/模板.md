# Ⅰ、基础算法



## 一、二分

### 1、整数二分

```cpp
// 区间 [l，r] 被划分成 [l, mid] 和 [mid + 1, r] 时使用 ：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid; // check()判断mid是否满足性质
        else l = mid + 1; // 不满足
    }
    return l;
}
// 区间 [l, r] 被划分成 [l, mid - 1] 和 [mid, r] 时使用 ：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid; // 满足
        else r = mid - 1; // 不满足
    }
    return l;
}
```

### 2、实数二分

```cpp
int bsearch(double l, double r)
{
    while (r - l > 1e-6) // 比答案小两个精确度即可
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

### 3、二分查找

```cpp
// 在从小到大排好序的数组中：
1. lower_bound (a + 1, a + n + 1, x) - a; // 找到第一个大于等于 x 的数
2. upper_bound (a + 1, a + n + 1, x) - a; // 找到第一个大于 x 的数
// 在从大到小排好序的数组中：
1. lower_bound (a + 1, a + n + 1, x, greater<int> () ) - a; // 找到第一个小于等于 x 的数
2. upper_bound (a + 1, a + n + 1, x, greater<int> () ) - a; // 找到第一个小于 x 的数
```



## 二、前缀和 and 差分

### 1、前缀和

预处理：O(n)，求一段数字的和：O(1)

快速求出一段数的和，可以当作数列 s 与 a 的关系

```cpp
// 求第 i 个数到第 j 个数: s[j] - s[i - 1]; (i <= j)
s[i] = s[i - 1] + a[i];
// 二位前缀和
s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];
```

### 2、差分

预处理：O(n) ，在 [l,  r] 区间上加  c : O(1)

```cpp
// [l, r]区间上每个数加上 c, 第 l 和 l - 1 个数之间的关系变了，第 r 和第 r + 1 个数的关系变了，但 [l, r] 之间的数关系不变
d[l] += c, d[r + 1] -= c;
// 二维差分 ，(x1, y2) 到 (x2, y2) 的子矩阵所有元素加上 c
d[x1][y1] += c;
d[x2 + 1][y1] -= c;
d[x1][y2 + 1] -= c;
d[x2 + 1][y2 + 1] += c;
```



## 三、搜索

### 1、dfs

### 2、bfs



## 四、STL

### 1、常用函数

```cpp
// 去重 O(n)
sort(a.begin(), a.end());
a.erase(unique(a.begin(), a.end()), a.end());
// 求和 O(n)
int sum = accumulate(a.begin(), a.end(), 0); // 左开右闭，初始值。
// 字符串转数字 O(n)
string str = "123";
int num = atoi(str.c_str());
// 数字转字符串 O(n)
int num = 123;
string str = to_string(num);
// 初始化 O(n)
fill(a.begin(), a.end(), 2); // memset只限定 0 or -1
// 判断升序 O(n)
bool flag = is_sorted(a.begin(), a.end());
// 二分查找 O(log(n)) 如果未找到，返回尾地址的下一个位置的地址 (a.end())
lower_bound(a.begin() + 1, a.end(), x); //  >= x
upper_bound(a.begin() + 1, a.end(), x); //  >  x
// 部分排序 O(log(m)) m 为部分序列长度
partial_sort(a, a.begin() + 1, a.begin() + 6); // a[1] ~ a[5] 排序 
```

### 2、vector

`vector`为可变长数组（动态数组），定义的`vector`数组可以随时添加数值和删除元素。

### 2、stack

### 4、queue

### 5、set

### 6、map

### 7、pair

### 8、string

### 9、bitset

### 10、array

### 11、tuple







# Ⅱ、动态规划



## 一、线性DP

### 2、LIS

二分优化 ：dp[i] (1 -> len) 存储递增序列中第 i 位的数字，length[i]存储第 i 位结尾时递增序列的长度。

LIS ：最长上升子序列

```cpp
const int N = 110;
int dp[N], length[N];
int len = 1;
void LIS(int a[], int n)
{
    dp[1] = a[1];
    length[1] = 1;
    for (int i = 2; i <= n; ++ i) 
    {
        if (a[i] > dp[len]) dp[++len] = a[i];
        else dp[lower_bound(dp + 1, dp + len + 1, a[i]) - dp] = a[i];
        length[i] = len;
    }
```

not_LIS ：最长非升子序列

```cpp
const int N = 110;
int dp[N], length[N];
int len = 1;
void not_LIS(int a[], int n)
{
    dp[1] = a[1];
    length[1] = 1;
    for (int i = 2; i <= n; ++ i)
    {
        if(a[i] <= dp[len]) dp[++len] = a[i];
        else dp[upper_bound(dp + 1,dp + len + 1, a[i], greater<int>()) - dp] = a[i];
        length[i] = len;
    }
}
```

LDS ：最长下降子序列

```cpp
const int N = 110;
int dp[N], length[N];
int len = 1;
void lDS(int a[], int n)
{
    dp[1] = a[1];
    length[1] = 1;
    for (int i = 2; i <= n; ++ i)
    {
        if (a[i] < dp[len]) dp[++len] = a[i];
        else dp[lower_bound(dp + 1,dp + len + 1, a[i], greater<int>()) - dp] = a[i];
        length[i] = len;
    }
```

not_LDS ：最长非降子序列

```cpp
const int N = 110;
int dp[N], length[N];
int len = 1;
void not_lDS(int a[], int n)
{
    dp[1] = a[1];
    length[1] = 1;
    for (int i = 2; i <= n; ++ i)
    {
        if (a[i] >= dp[len]) dp[++len] = a[i];
        else dp[upper_bound(dp + 1, dp + len + 1, a[i]) - dp] = a[i];
        length[i] = len;
    }
}
```

把序列分成不上升子序列的最少个数，等于序列的最长上升子序列长度。
把序列分成不下降子序列的最少个数，等于序列的最长下降子序列长度。



## 二、背包DP

### 1、01背包

每件物品最多使用一次 

```cpp
const int N = 1010;
int dp[N], v[N], w[N];
Accepted()
{
    int n, V; cin >> n >> V;    
    for (int i = 1; i <= n; ++ i) cin >> v[i] >> w[i];
    for (int i = 1; i <= n; ++ i)
    {
        for (int j = V; j >= v[i]; -- j)
        {
            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
        } 
    }
    cout << dp[V] << "\n";
}
```

### 2、完全背包

每件物品无限个

```cpp
const int N = 1010;
int dp[N], v[N], w[N];
Accepted()
{
    int n, V; cin >> n >> V;
    for (int i = 1; i <= n; ++ i) cin >> v[i] >> w[i];
    for (int i = 1; i <= n; ++ i)
    {
        for (int j = v[i]; j <= V; ++ j)
        {
            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
        } 
    }
    cout << dp[V] << "\n";
}
```

### 3、多重背包

每件物品个数不一样

```cpp
const int N = 2e5 + 10;
int dp[N], v[N], w[N];
Accepted()
{
    int n, V; cin >> n >> V;
    int cnt = 0;
    for (int i = 1, a, b, s; i <= n; ++ i) 
    {
        cin >> a >> b >> s;         // 体积，价值，数量     
        int k = 1;                  // 第一组的个数
        while (k <= s)              // 打包分组，二进制拆分
        {
            ++ cnt;                 // 当前组的编号 
            v[cnt] = a * k;         // 当前组的总体积 
            w[cnt] = b * k;         // 当前组的总价值 
            s -= k;                 // 当前组的剩余个数 
            k *= 2;                 // 下一组的个数 
        }
        if (s > 0)                  // 剩下的物品
        {
            ++ cnt;
            v[cnt] = a * s;
            w[cnt] = b * s;
        }
    } 
    for (int i = 1; i <= cnt; ++ i) // 01背包 
    {
        for (int j = V; j >= v[i]; -- j)
        {
            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
        } 
    } 
    cout << dp[V] << "\n";
}
```

### 4、分组背包

物品有 n 组，每一组物品有若干个，只能选一个

```cpp
const int N = 110;
int dp[N], v[N][N], w[N][N], s[N];
Accepted()
{
    int n, V; cin >> n >> V;
    for (int i = 1; i <= n; ++ i)
    {
        cin >> s[i];
        for (int j = 0; j < s[i]; ++ j)
        {
            cin >> v[i][j] >> w[i][j];
        }
    }
    for (int i = 1; i <= n; ++ i)
    {
        for (int j = V; j >= 0; -- j)
        {
            for (int k = 0; k < s[i]; ++ k)
            {
                if (v[i][k] <= j) dp[j] = max(dp[j], dp[j - v[i][k]] + w[i][k]);
            }
        }
    }
    cout << dp[V] << "\n";
}
```



## 三、树形DP

### 1、普通

```cpp
const int N = 123;
struct node
{
    int v, w;
    node (int v = 0, int w = 0) : v(v), w(w) {}
};
int dp[N][N];
int sum[N];
vector<node> edge[N];
int n, m; // n 个节点，m 条边
void dfs(int u, int fa)
{
    for (int i = 0; i < edge[u].size(); ++ i)
    {
        int v = edge[u][i].v, w = edge[u][i].w;
        if (v == fa) continue; // 防止循环出不来
        dfs(v, u); // 先找到子节点然后才可以进行计算
        sum[u] += sum[v] + 1; // 计算，以 u 为父节点，它的总边数等于 (u, v) 这条边 + 以 v 为父节点的总边数。
        for (int j = min(sum[u], m); j >= 0; -- j)
        {
            for (int k = 0; k <= max(sum[v], j - 1); ++ k)
            {
                dp[u][j] = max(dp[u][j], dp[v][k] + dp[u][j - k - 1] + w); 
                // 以 u 为父节点，保留 j 条边，分为 : 以 v 为子节点保留 k 条边，u 为父节点的其它边，(u, v) 这一条边。
            }
        }
    }    
}
void Accepted()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i < n; ++ i)
    {
        int u, v, w;
        cin >> u >> v >> w;
        edge[u].push_back(node{v, w});
        edge[v].push_back(node{u, w});
    }
    dfs(1, 0);
    cout << dp[1][m] <<"\n";
}
```

### 2、最小支配集

```cpp
const int N = 2e5 + 10;
int dp[N][3];
// dp[i][0], 表示点 i 属于支配集合, 并且以点 i 为根的子树都被覆盖了的情况下支配集中所包含最少点的个数.
// dp[i][1], 表示点 i 不属于支配集合, 且以 i 为根的子树都被覆盖,且 i 被其中不少于一个子节点覆盖的情况下支配集所包含最少点的个数.
// dp[i][2], 表示点 i 不属于支配集合, 且以 i 为根的子树都被覆盖,且 i 没被子节点覆盖的情况下支配集中所包含最少点的个数.即 i 将被父节点覆盖。
vector<int> g[N]; // 存图
int w[N]; // 记录边权
void dfs(int u, int fa)
{
    int flag = 0;
    int inc = INF;
    dp[u][0] = w[u];
    dp[u][1] = 0;
    dp[u][2] = 0;
    for (int i = 0; i < g[u].size(); ++ i)
    {
        int v = g[u][i];
        if (v == fa) continue;
        dfs(v, u);
        dp[u][0] += min(dp[v][0], min(dp[v][1], dp[v][2]));
        //选择 u 父节点，则 v 子节点状态无所谓。
        dp[u][2] += min(dp[v][0], dp[v][1]);
        // v 子节点状态只能有 0 1 两种，若为 2 则说明 v 被 u 覆盖，与 u 不选相矛盾。
        if (dp[v][0] <= dp[v][1])
        {
            flag = 1;
            dp[u][1] += dp[v][0];
        }
        else 
        {
            inc = min(inc, (dp[v][0] - dp[v][1]));
            dp[u][1] += dp[v][1];
        }
        // <= 更优，且合情合理；大于则需打标记防止如下情况。
    }
    if (!flag) dp[u][1] += inc; 
    // 如果状态一直从 dp[v][1] 转移到 dp[u][1]，则没有一个v是被选择的，出现错误，所以强制选择一个最小的。
}
void Accepted()
{
    int n;
    cin >> n;
    memset(g, 0, sizeof g);
    for (int i = 1; i <= n; ++ i)
    {
        cin >> w[i];
        dp[i][0] = dp[i][1] = dp[i][2] = 0;
    }
    for (int i = 1; i < n; ++ i)
    {
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs(1, 0);
    cout << min(dp[1][0], dp[1][1]) << "\n";
    // 1 为根节点，根节点只有 0 1 两种状态。
}
```

### 3、换根DP

```cpp
const int N = 1e6 + 10;
vector<int> g[N]; // 存图
int siz[N], dep[N], ans[N]; 
// siz 存放该节点的子树大小（包括自己），dep[i] 存放以 1 为根时 i 节点的深度，ans 存放所有结点的深度之和
void dfs(int u,int fa) // 第一次完成预处理（如子树大小等），同时得到该节点的解
{
    siz[u] = 1; // 1 为 1 层
    for(auto v : g[u])
    {
        if(v == fa) continue;
        dfs(v, u);
        siz[u] += siz[v];
        dep[u] += dep[v] + 1;
    }
}
void DP(int u,int fa) // 第二次进行换根的动态规划，由已知解的节点推出相连节点的解
{
    for(auto v : g[u])
    {
        if(v == fa) continue;
        ans[v] = ans[u] - siz[v] * 1ll + (siz[1] - siz[v]) * 1ll;
        DP(v, u);
    }
}
void Accepted()
{
    int n; cin >> n;
    for(int i = 1, u, v; i < n; ++ i)
    {
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs(1, 0);
    for (int i = 1; i <= n; ++ i) ans[1] += dep[i]; // 计算以 1 为根节点时的深度和
    DP(1, 0); 
    int maxn = -1, p = 0; // p 为节点
    for(int i = 1; i <= n; ++ i)
    {
        if(maxn < ans[i]) { maxn = ans[i]; p = i;}
    }
    cout << p << "\n";
}
```



## 四、概率DP



## 五、期望DP



## 六、数位DP



## 七、区间DP





# Ⅲ、数学



## 一、质数

![质数](D:\MY ACM\资料\image\prime.png)
### 1、判定质数
试除法判断是否为小质数   O(sqrt(n)) 
```cpp
bool is_prime(int n)
{
    if (n < 2) return false;
    for (int i = 2; i <= n / i; i++) if (n % i == 0) return false;
    return true;
}
```
### 2、质数筛
求 1 ~ n 中的质数 （1e5 以内的质数个数不超过 9.6e3 ，1e7 以内的质数个数不超过 6.7e6 ，1e9 以内的质数不超过 5.1e7 ）
```cpp
// 埃式筛法 (思想重要，比赛不用)
// 从 2 到 n 枚举，把倍数筛掉，但是一个合数可能会重复筛掉很多次
const int N = 1e5 + 10;
int prime[N], cnt = 0;
bool vis[N]; 
void E_sieve()
{
    for (int i = 2; i <= N; i ++ )
    {
        if (!vis[i]) prime[++ cnt] = i; //当前的数没有被筛过 
        for (int j = i + i; j <= N; j += i) vis[j] = true; //  只有当前数是质数时才把质数的倍数删掉 
    }
}
```
```cpp
// 欧拉筛 (比赛主用)
// n 只会被最小质因子筛掉，每个数只会被筛一次，所以为线性 
const int N = 1e5 + 10;
int prime[N], cnt = 0;
bool vis[N];
int a[N]; // 计算前 i 个数字中有多少个质因数
void euler()
{
    a[1] = 0;
    vis[1] = 1;
    for (int i = 2; i <= N; ++ i)
    {
        if (!vis[i]) prime[++ cnt] = i, a[i] = 1;//当前的数没有被筛过    
        for (int j = 1; j <= cnt; ++ j)//从小到大枚举质数 
        {
            if (i * prime[j] > N) break;
            vis[i * prime[j]] = true; // 把 primes[j] * i 筛掉 
            // a[i * prime[j]] = a[i] + 1;
            if (i % prime[j] == 0) break;
            // 这意味着 primes[j] 一定是 i 的最小质因子，primes[j] 也一定是 primes[j] * i 的最小质因子
            // 若不等于 0 ，primes[j] 一定小于i的所有质因子，primes[j] 也一定是 primes[j] * i 的最小质因子
        }
    }
}
```
### 3、分解质因数
试除法 O(sqrt(n))
把合数分解为质数相乘，若为质数则直接输出，从小到大枚举所有约数，n 中最多只包含一个大于 sqrt(n) 的质因子 
```cpp
int calc(int n)
{
    int cnt = 0;
    for (int i = 2; i <= n / i; ++ i)
        if (n % i == 0) // 只要此条件成立，i 一定为质数 
        {
            int cnt = 0;
            while (n % i == 0)
            {
                n /= i;
                ++ cnt; // i 即为 n 的质因数，s 为 i 的次数
            }
        }
    if (n > 1) ++ cnt; //唯一大于 sqrt(n) 的质因子 (若为质数则直接输出)
    return cnt;
} 
```
### 4、欧拉筛求最小质因数
```cpp
const int N = 1e5 + 10;
int prime[N], cnt = 0;
int vis[N];
void euler(int n)
{
    for (int i = 2; i <= n; i++)
    {
        if (!vis[i]) {prime[++ cnt] = i, vis[i] = i;} // 当前的数没有被筛过   
        for (int j = 1; j <= cnt; j++)                // 从小到大枚举质数 
        {
            if (i * prime[j] > n) break;
            vis[i * prime[j]] = prime[j]; 
            if (i % prime[j] == 0) break; 
        }
    }
}
```



## 二、因数

![因数](D:\MY ACM\资料\image\factor.png)
### 1、求因数
求正整数 n 的所有因数（因数和质数一样也是成对出现)
80  ：1 2 4 5 8 10 16 20 40 80

```cpp
const int N = 1e5 + 10;
vector<int> factor;
void divisor() // 较快
{
    for (int i = 1; i < N; ++ i)
    {
        for (int j = i; j < N; j += i)
        {
        	factor[j].push_back(i);
        }
    }
}
//=====================================================//
const int N = 1e5 + 10;
vector<int> factor;
void divisor(int n) // 较慢
{   
    for (int i = 1; i <= n / i; ++ i)
        if (n % i == 0)
        {
            factor[n].push_back(i);
            if (i != n / i) factor[n].push_back(n / i);
        }
    sort(factor[n].begin(), factor[n].end());
}
for (int i = 1; i <= n; ++ i) divisor(i);
```
### 2、计算 n 的质因数总个数
```cpp
const int N = 1e5 + 10;
int prime[N], cnt = 0;
int vis[N];
void euler(int n)
{
    for (int i = 2; i <= n; ++ i)
    {
        if (!vis[i]) {prime[++ cnt] = i, vis[i] = i;} // 当前的数没有被筛过   
        for (int j = 1; j <= cnt; ++ j)                // 从小到大枚举质数 
        {
            if (i * prime[j] > n) break;
            vis[i * prime[j]] = prime[j]; 
            if (i % prime[j] == 0) break; 
        }
    }
}
int calc(int n)
{
    if(n == 1) return 0;
    int ret = 1, i = 1;
    while(n > 1)
    {
        if(prime[i] >= n || i > cnt) break;
        if(n % prime[i] == 0)
        {
            ++ ret;
            n /= prime[i];
        }
        else ++ i;
    }
    return ret;
}
```
### 3、**计算** **n** 的因数总个数
根据算术基本定理分解 n ，则个数为 (a1 + 1) * (a2 + 1) * ...... * (ak + 1) ，k 为质数的顺序，a 为指数
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int MOD = 1e9 + 7;
signed main()
{
    int n; cin >> n;
    map <int, int> primes;
    for (int i = 2; i <= n / i; i ++ )
        while (n % i == 0)
        {
            n /= i;
            primes[i] ++ ;
        }
    if (n > 1) primes[n] ++ ;//说明 n 是一个比较大的质因数，所以加上去
    int res = 1; // 因数总个数
    map <int, int> :: iterator it = primes.begin();
    for (it; it != primes.end(); it ++ ) res = res * (it->second + 1) % MOD;
    cout << res << "\n";
    return 0;
}
```
### 4、**计算** **n** 的所有因数之和
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int MOD = 1e9 + 7;
signed main()
{
    int n; cin >> n;
    map <int, int> primes;
    for (int i = 2; i <= n / i; i++)
    while (n % i == 0)
    {
        n /= i;
        primes[i] ++;
    }
    if (n > 1) primes[n] ++; // 说明 n 是一个比较大的质因数，所以加上去
    int sum = 1;
    for (auto prime : primes)
    {
        int p = prime.first, a = prime.second; // p为底数，a为指数
        int t = 1;
        while (a--) t = (t * p + 1) % MOD;
        sum = sum * t % MOD;
    }
    cout << sum << "\n";
    return 0;
}
```
### 5、GCD and LCM
```cpp
// 最大公因数  (欧几里得算法，又称辗转相除法) O(log min(a, b))
int gcd(int a, int b) {return b ? gcd(b, a % b) : a;}
// 最小公倍数  gcd(a, b) * lcm(a, b) == a * b
int lcm(int a, int b) {return a / gcd(a, b) * b;}
```



## 三、exgcd



## 四、组合数

### 1、鸽巢原理 
把 m 个物品分给 n 个人，每个人最少拿到 (m - 1) / n + 1 个物品。
### 2、排列组合
```cpp
const int N = 2e5 + 10;
const int mod = 998244353;
struct Fac
{
    int power(int a, int n)
    {
        int ans = 1;
        while (n)
        {
            if (n & 1) ans = ans * a % mod;
            a = a * a % mod;
            n >>= 1;
        }
        ans %= mod;
        return ans;
    }
    vector<int> fac, inv_fac;
    Fac() : fac(N), inv_fac(N)
    {
        fac[0] = 1;
        for(int i = 1; i <= N - 5; ++ i)
        {
            fac[i] = fac[i - 1] * i % mod;
        }
        inv_fac[N - 5] = power(fac[N - 5], mod - 2);
        for(int i = N - 5; i > 0; -- i)
        {
            inv_fac[i - 1] = inv_fac[i] * i % mod;
        }
    }
    int C(int n, int m)
    {
        if(n < m or m < 0) return 0ll;
        return fac[n] * inv_fac[m] % mod * inv_fac[n - m] % mod;
    }
    int A(int n, int m)
    {
        if(n < m or m < 0) return 0ll;
        return fac[n] * inv_fac[n - m] % mod;
    }
} fac;
```

### 3、球盒模型

https://zhuanlan.zhihu.com/p/602410836

b1：将个 n **无标号**的球放到个 k **无标号**的盒子中，盒子**允许为空**。

```cpp
int calc(int n, int k)
{
    if (n == 0) return 1;
    if (k == 0) return 0;
    if (n < k) return calc(n, n);
    return calc(n, k - 1) + calc(n - k, k);
}
```

b2：将个 n **无标号**的球放到个 k **无标号**的盒子中，盒子**不允许为空**。

```cpp
int calc1(int n, int k)
{
    if (n == 0) return 1;
    if (k == 0) return 0;
    if (n < k) return calc1(n, n);
    return calc1(n, k - 1) + calc1(n - k, k);
}
int calc2(int n, int k)
{
    if (n < k) return 0;
    return calc1(n - k, k);
}
```

b3：将个 n **无标号**的球放到个 k **有标号**的盒子中，盒子**允许为空**。

```cpp
int cnt = c[n + k - 1][k - 1];
```

b4：将个 n **无标号**的球放到个 k **有标号**的盒子中，盒子**不允许为空**。

```cpp
int cnt = c[n - 1][k - 1];
```

b5：将个 n **有标号**的球放到个 k **无标号**的盒子中，盒子**允许为空**。

```cpp

```

b6：将个 n **有标号**的球放到个 k **无标号**的盒子中，盒子**不允许为空**。

```cpp
```

### 4、容斥原理

```cpp
// 题目：n 为 1e6，f[k] 代表以 k 为 gcd 的（i，j）对数，求 f[1] -> f[n] 。
// 思路：先求出以 k 以及其倍数为 gcd 的数对个数(i 和 j 都有 n / k 种选择)，减掉以 k 的倍数为 gcd 的数对个数，求出 f[k] 。
// f[2] = (f[2] + f[4] + f[6] + ......) - (f[4] - f[6] - ......)
// 		        (n / k) * (n / k)       -     逆序for循环求解
for (int i = n; i >= 1; -- i)
{
    f[i] = (n / k) * (n / k);
    for (int j = i << 1; j <= n; j += i) f[i] -= f[j];
}
```



## 五、位运算

### 1、普通
```cpp
与    &    两个位都为 1 时，结果才为 1
或    |    两个位都为 0 时，结果才为 0
非(取反)  ~ 0变1，1变0 
异或   ^   (相同为 0 ，否则为 1 ；异或 0 不变，异或 1 取反)
(异或、异或互为逆运算，加、减互为逆运算，乘、除互为逆运算)
-x == ~x + 1
x & -x == x & (~x + 1)
去掉最后一位：      x >> 1
在最后加一个0：     x << 1
在最后加一个1：     (x << 1) + 1
把最后一位变成1：   x | 1
把最后一位变成0：   (x | 1) - 1
最后一位取反：      x ^ 1
把右数第k位变成1：  x | (1 << (k - 1))
把右数第k位变成0：  x & (~(1 << (k - 1)))
右数第k位取反：     x ^ (1 << (k - 1))
求n的第k位数字：    n >> k & 1
返回n的最后一位1：  lowbit(n) = n & -n
```
### 2、二进制拆位算贡献






# Ⅳ、数据结构



## 一、并查集

```cpp
const int N = 1e6 + 10;
int fa[N], ra[N];
// 初始化（父节点初始化为本身）
void init(int n)
{
    for (int i = 1; i <= n; ++i)
    {
        fa[i] = i;
        ra[i] = 1;
    }
}
// 查找父节点（普通）
int find(int x)
{
    if(fa[x] != x) return find(fa[x]);
    return x;
}
// 查找父节点（过程中路径压缩）
int find(int x) {return fa[x] == x ? x : (fa[x] = find(fa[x]));}
// 合并父节点（普通）
void merge(int x, int y) {fa[find(x)] = find(y);}
// 合并父节点（按秩合并，短层并到长层）
void merge(int x, int y)
{
    int fx = find(x), fy = find(y);
    if (ra[fx] >= ra[fy]) fa[fy] = fx;
    else fa[fx] = fy;
    if (ra[fx] == ra[fy] && fx != fy) ++ ra[fx];
}
```



## 二、线段树

### 1、区间加

```cpp
const int N = 1e5 + 10;
int tree[N << 2], tag[N << 2], a[N], n;
void build(int p = 1, int cl = 1, int cr = n) // current l, r
{
    if (cl == cr) 
    {
        tree[p] = a[cl];
        return ;
    }
    int mid = (cl + cr) >> 1;
    build(p << 1, cl, mid);
    build(p << 1 | 1, mid + 1, cr);
    tree[p] = tree[p << 1] + tree[p << 1 | 1];
}
void push_down(int p, int len)
{
    if (tag[p])
    {
        tree[p << 1] += tag[p] * (len - len / 2);
        tree[p << 1 | 1] += tag[p] * (len / 2);
        tag[p << 1] += tag[p];
        tag[p << 1 | 1] += tag[p];
    }
    tag[p] = 0;
}
void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n)
{
    if (cl >= l && cr <= r) 
    {
        tree[p] += d * (cr - cl + 1);
        tag[p] += d;
        return ;
    }
    push_down(p, cr - cl + 1);
    int mid = (cl + cr) >> 1;
    if (mid >= l) update(l, r, d, p << 1, cl, mid);
    if (mid < r) update(l, r, d, p << 1 | 1, mid + 1, cr);
    tree[p] = tree[p << 1] + tree[p << 1 | 1];
}
int query(int l, int r, int p = 1, int cl = 1, int cr = n)
{
    if (cl >= l && cr <= r) return tree[p];
    push_down(p, cr - cl + 1);
    int mid = (cl + cr) >> 1, ans = 0;
    if (mid >= l) ans += query(l, r, p << 1, cl, mid);
    if (mid < r) ans += query(l, r, p << 1 | 1, mid + 1, cr);
    return ans;
}
// build();
// update(l, r, k);
// query(l, r);
```

### 2、先乘后加

```cpp
const int N = 1e5 + 10;
int tree[N << 2], tag1[N << 2],tag2[N << 2], a[N], n, mod;
void build(int p = 1, int cl = 1, int cr = n) // current l, r
{
    tag1[p] = 1 % mod;
    tag2[p] = 0 % mod;
    if (cl == cr)
    {
        tree[p] = a[cl];    
        return ;
    }
    int mid = (cl + cr) >> 1;
    build(p << 1, cl, mid);
    build(p << 1 | 1, mid + 1, cr);
    tree[p] = (tree[p << 1] + tree[p << 1 | 1]) % mod;
}
void push_down(int p, int len)
{
    if (tag[p])
    {
        tree[p << 1] = (tree[p << 1] * tag1[p] + tag2[p] * (len - len / 2)) % mod;
        tree[p << 1 | 1] = (tree[p << 1 | 1] * tag1[p] + tag2[p] * (len / 2)) % mod;
        tag1[p << 1] = (tag1[p << 1] * tag1[p]) % mod;
        tag1[p << 1 | 1] = (tag1[p << 1 | 1] * tag1[p]) % mod;
        tag2[p << 1] = (tag2[p << 1] * tag1[p] + tag2[p]) % mod;
        tag2[p << 1 | 1] = (tag2[p << 1 | 1] * tag1[p] + tag2[p]) % mod;
    }
    tag1[p] = 1;
    tag2[p] = 0;
}
void update1(int l, int r, int d, int p = 1, int cl = 1, int cr = n)
{
    if (cl >= l && cr <= r) 
    {
        tree[p] = tree[p] * d % mod;
        tag1[p] = tag1[p] * d % mod;
        tag2[p] = tag2[p] * d % mod;
        return ;
    }
    push_down (p, cr - cl + 1);
    int mid = (cl + cr) >> 1;
    if (mid >= l) update1(l, r, d, p << 1, cl, mid);
    if (mid < r) update1(l, r, d, p << 1 | 1, mid + 1, cr);
    tree[p] = (tree[p << 1] + tree[p << 1 | 1]) % mod;
}
void update2(int l, int r, int d, int p = 1, int cl = 1, int cr = n)
{
    if (cl >= l && cr <= r) 
    {
        tree[p] = (tree[p] + d * (cr - cl + 1)) % mod;
        tag2[p] = (tag2[p] + d) % mod;
        return ;
    }
    push_down (p, cr - cl + 1);
    int mid = (cl + cr) >> 1;
    if (mid >= l) update2(l, r, d, p << 1, cl, mid);
    if (mid < r) update2(l, r, d, p << 1 | 1, mid + 1, cr);
    tree[p] = (tree[p << 1] + tree[p << 1 | 1]) % mod;
}
int query(int l, int r, int p = 1, int cl = 1, int cr = n)
{
    if (cl >= l && cr <= r) return tree[p];
    push_down(p, cr - cl + 1);
    int mid = (cl + cr) >> 1, ans = 0;
    if (mid >= l) ans = (ans + query(l, r, p << 1, cl, mid)) % mod;
    if (mid < r) ans = (ans + query(l, r, p << 1 | 1, mid + 1, cr)) % mod;
    return ans % mod;
}
// build();
// update1(l, r, k);
// updete2(l, r, k);
// query(l, r);
```

### 3、维护最值

```cpp
const int N = 1e5 + 10;
int tree[N << 2], a[N], n;
void build(int p = 1, int cl = 1, int cr = n) // current l, r
{
    if (cl == cr) 
    {
        tree[p] = a[cl];
        return ;
    }
    int mid = (cl + cr) >> 1;
    build(p << 1, cl, mid);
    build(p << 1 | 1, mid + 1, cr);
    // tree[p] = min(tree[p << 1], tree[p << 1 | 1]);
    tree[p] = max(tree[p << 1], tree[p << 1 | 1]);
}
void update(int l, int r, int d, int p = 1, int cl = 1, int cr = n)
{
    if (cl >= l && cr <= r) 
    {
        tree[p] = d;
        return ;
    }
    int mid = (cl + cr) >> 1;
    if (mid >= l) update(l, r, d, p << 1, cl, mid);
    if (mid < r) update(l, r, d, p << 1 | 1, mid + 1, cr);
    // tree[p] = min(tree[p << 1], tree[p << 1 | 1]);
    tree[p] = max(tree[p << 1], tree[p << 1 | 1]);
}
int query(int l, int r, int p = 1, int cl = 1, int cr = n)
{
    if (cl >= l && cr <= r) return tree[p];
    int mid = (cl + cr) >> 1, ans = 0;
    // if (mid >= l) ans = min(ans, query(l, r, p << 1, cl, mid));
    // if (mid < r) ans = min(ans, query(l, r, p << 1 | 1, mid + 1, cr));
    if (mid >= l) ans = max(ans, query(l, r, p << 1, cl, mid));
    if (mid < r) ans = max(ans, query(l, r, p << 1 | 1, mid + 1, cr));
    return ans;
}
// build();
// update(l, r, k);
// query(l, r);
```

### 4、权值线段树

整个序列的第 k 大 、小值是什么

```cpp
const int N = 1e5 + 10;
int tree[N << 2], a[N], n;
void build(int p = 1, int cl = 1, int cr = n) // current l, r
{
    if (cl == cr) 
    {
        tree[p] = a[cl]; // 数字 cl 的个数
        return ;
    }
    int mid = (cl + cr) >> 1;
    build(p << 1, cl, mid);
    build(p << 1 | 1, mid + 1, cr);
    tree[p] = tree[p << 1] + tree[p << 1 | 1];
}
void update(int k, int cnt, int p = 1, int cl = 1, int cr = n) // 更改 k 的个数，类似单点修改
{
    if (cl == cr) 
    {
        tree[p] += cnt; 
        return ;
    }
    int mid = (cl + cr) >> 1;
    if (mid >= k) update(k, cnt, p << 1, cl, mid);
    if (mid < k) update(k, cnt, p << 1 | 1, mid + 1, cr); 
    tree[p] = tree[p << 1] + tree[p << 1 | 1];
}
int query(int k, int p = 1, int cl = 1, int cr = n) // 查询数字 k 的个数，类似单点查询
{
    if (cl == cr) return tree[p];
    int mid = (cl + cr) >> 1;
    if (mid >= k) return query(k, p << 1, cl, mid);
    if (mid < k) return query(k, p << 1 | 1, mid + 1, cr);
}
int k_min(int k, int p = 1, int cl = 1, int cr = n) // 查询第 k 小的数字
{
    if (cl == cr) return cl;
    int mid = cl + cr >> 1;
    if (tree[p << 1] >= k) return k_min(k, p << 1, cl, mid);
    else return k_min(k - tree[p << 1], p << 1 | 1, mid + 1, cr);
}
int k_max(int k, int p = 1, int cl = 1, int cr = n) // 查询第 k 大的数字
{
    if(cl == cr) return cl;
    int mid = cl + cr >> 1;
    if(tree[p << 1 | 1] >= k) return k_max(k, p << 1 | 1,mid + 1, cr);
    else return k_max(k - tree[p << 1 | 1], p << 1, cl, mid);
}
// build();
// update(k, cnt);
// query(k);
// k_min(k);
// k_max(k);
```



## 二、树状数组

单点修改 + 区间查询 or 区间修改 + 单点查询

```cpp
const int N = 1e5 + 10;
int tree[N];
int lowbit(int x) {return (x & (-x));}
inline void modify(int pos, int x)
{
    for (int i = pos; i < N; i += lowbit(i)) tree[i] += x;
}
inline int query(int pos)
{
    int ans = 0;
    for (int i = pos; i; i -= lowbit(i)) ans += tree[i];
    return ans;
}
```





# Ⅴ、字符串



## 一、字典树

插入和查询O(m)  ,（m为字符串长度）

```cpp
const int N = 5e5 + 10;
int nxt[N][26], cnt = 0;
// bool exist[N];
void init() // 初始化
{
    memset(nxt, 0, sizeof nxt); // 全部重置为 0 ，表示当前点没有存储字符
    // memset(exist, false, sizeof exist); 查单词
    cnt = 0;
}
void insert(string s) // 插入
{
    int cur = 0;
    for (auto c : s)
    {
        if (!nxt[cur][c - 'a']) nxt[cur][c - 'a'] = ++cnt; // 尽可能重用之前的路径，如果做不到则新建节点
        cur = nxt[cur][c - 'a']; // 继续向下
    }
    // exist[cur] = true; // 单词结尾
}
bool find(string s) // 查找某个前缀（或单词）是否出现过，注意函数类型的修改（int）
{
    int cur = 0;
    for (auto c : s)
    {
        if (!nxt[cur][c - 'a']) return false; // 沿着前缀所决定的路径往下走，如果中途发现某个节点不存在，说明前缀不存在
        cur = nxt[cur][c - 'a'];
    }
    // if (!exist[cur]) return false; // 该点不是单词结尾
    return true;
}
```











# Ⅵ、计算几何



## 一、三角函数

```cpp
cos  余弦函数
sin  正弦函数
tan  正切函数
acos 反余弦函数
asin 反正弦函数
atan 反正切函数

exp  e 的 x 次方
pow 计算 x 的 y 次幂
sqrt  开方、平方根

cosh 求 x 的双曲余弦值
sinh 求 x 的双曲正弦值
tanh 求 x 的双曲正切值

abs  绝对值函数
fabs 求浮点数 x 的绝对值
ceil 求不小于 x 的最小整数 
fmod 计算 x / y 的余数 

frexp 把浮点数 x 分解成尾数和指数
modf  把数分为指数和尾数
hypot 对于给定的直角三角形的两个直角边，求其斜边的长度

ldexp 装载浮点数
loge  e 为底对数
log10  10 为底对数

将角度转化为弧度 : 角度 *  PI / 180
例：求 sin30° : sin(30 * PI / 180) == 0.5
```



## 二、公式

### 1、正多边形内角度数计算公式

```cpp
(n - 2) * 180 / n
```

### 2、海伦公式

![三角公式](D:\MY ACM\资料\image\hailun.png)



## 三、模板

```cpp
#include <bits/stdc++.h>
using namespace std;
using point_t = long double;  //全局数据类型，可修改为 long long 等
constexpr point_t eps = 1e-8;
constexpr long double PI = 3.1415926535897932384l;
```

### 1、点与向量

```cpp
// 点与向量
template <typename T> struct point
{
    T x, y;
    bool operator ==(const point &a) const { return (abs(x - a.x) <= eps && abs(y - a.y) <= eps); }
    bool operator <(const point &a) const
    {
        if (abs(x - a.x) <= eps) return y < a.y - eps;
        return x < a.x - eps;
    }
    bool operator >(const point &a) const { return !(*this < a || *this == a); }
    point operator +(const point &a) const { return {x + a.x, y + a.y}; }
    point operator -(const point &a) const { return {x - a.x, y - a.y}; }
    point operator -() const { return {-x, -y}; }
    point operator *(const T k) const { return {k * x, k * y}; }
    point operator /(const T k) const { return {x / k, y / k}; }
    T operator *(const point &a) const { return x * a.x + y * a.y; } // 点积
    T operator ^(const point &a) const { return x * a.y - y * a.x; } // 叉积，注意优先级
    int toleft(const point &a) const
    {
        const auto t = (*this) ^ a;
        return (t > eps) - (t < -eps);
    } // to-left 测试，a 为向量，1 为左
    T len2() const { return (*this) * (*this); }                     // 向量长度的平方
    T dis2(const point &a) const { return (a - (*this)).len2(); }    // 两点距离的平方
    // 涉及浮点数
    long double len() const { return sqrtl(len2()); }                // 向量长度
    long double dis(const point &a) const { return sqrtl(dis2(a)); } // 两点距离
    long double ang(const point &a) const { return acosl(max(-1.0l, min(1.0l, ((*this) * a) / (len() * a.len())))); } // 向量夹角
    point rot(const long double rad) const { return {x * cos(rad) - y * sin(rad), x * sin(rad) + y * cos(rad)}; } // 逆时针旋转（给定角度）
    point rot(const long double cosr, const long double sinr) const { return {x * cosr - y * sinr, x * sinr + y * cosr}; } // 逆时针旋转（给定角度的正弦与余弦）
};
using Point = point<point_t>;
```

### 2、极角排序

```cpp
// 极角排序
struct argcmp
{
    bool operator()(const Point &a, const Point &b) const
    {
        const auto quad = [](const Point &a)
        {
            if (a.y < -eps) return 1;
            if (a.y > eps) return 4;
            if (a.x < -eps) return 5;
            if (a.x > eps) return 3;
            return 2;
        };
        const int qa = quad(a), qb = quad(b);
        if (qa != qb) return qa < qb;
        const auto t = a ^ b;
        // if (abs(t)<=eps) return a*a<b*b-eps;  // 不同长度的向量需要分开
        return t > eps;
    }
};
```

### 3、直线

```cpp
template <typename T> struct line
{
    point<T> p, v; // p 为直线上一点，v 为方向向量
    bool operator==(const line &a) const { return v.toleft(a.v) == 0 && v.toleft(p - a.p) == 0; }
    int toleft(const point<T> &a) const { return v.toleft(a - p); } // to-left 测试
    bool operator<(const line &a) const                             // 半平面交算法定义的排序
    {
        if (abs(v ^ a.v) <= eps && v * a.v >= -eps) return toleft(a.p) == -1;
        return argcmp()(v, a.v);
    }

    // 涉及浮点数
    point<T> inter(const line &a) const { return p + v * ((a.v ^ (p - a.p)) / (v ^ a.v)); } // 直线交点
    long double dis(const point<T> &a) const { return abs(v ^ (a - p)) / v.len(); }         // 点到直线距离
    point<T> proj(const point<T> &a) const { return p + v * ((v * (a - p)) / (v * v)); }    // 点在直线上的投影
};
using Line = line<point_t>;
```

### 4、线段

```cpp
template <typename T> struct segment
{
    point<T> a, b; // 判定性函数建议在整数域使用
    bool operator<(const segment &s) const { return make_pair(a, b) < make_pair(s.a, s.b); }
    // 判断点是否在线段上 ：-1 点在线段端点 | 0 点不在线段上 | 1 点严格在线段上
    int is_on(const point<T> &p) const
    {
        if (p == a || p == b) return -1;
        return (p - a).toleft(p - b) == 0 && (p - a) * (p - b) < -eps;
    }
    // 判断线段直线是否相交 ：-1 直线经过线段端点 | 0 线段和直线不相交 | 1 线段和直线严格相交
    int is_inter(const line<T> &l) const
    {
        if (l.toleft(a) == 0 || l.toleft(b) == 0) return -1;
        return l.toleft(a) != l.toleft(b);
    }
    // 判断两线段是否相交 ：-1 在某一线段端点处相交 | 0 两线段不相交 | 1 两线段严格相交
    int is_inter(const segment<T> &s) const
    {
        if (is_on(s.a) || is_on(s.b) || s.is_on(a) || s.is_on(b)) return -1;
        const line<T> l{a, b - a}, ls{s.a, s.b - s.a};
        return l.toleft(s.a) * l.toleft(s.b) == -1 && ls.toleft(a) * ls.toleft(b) == -1;
    }
    // 点到线段距离
    long double dis(const point<T> &p) const
    {
        if ((p - a) * (b - a) < -eps || (p - b) * (a - b) < -eps) return min(p.dis(a), p.dis(b));
        const line<T> l{a, b - a};
        return l.dis(p);
    }
    // 两线段间距离
    long double dis(const segment<T> &s) const
    {
        if (is_inter(s)) return 0;
        return min({dis(s.a), dis(s.b), s.dis(a), s.dis(b)});
    }
};
using Segment = segment<point_t>;
```

### 5、多边形

```cpp
template <typename T> struct polygon
{
    vector<point<T>> p; // 以逆时针顺序存储
    size_t nxt(const size_t i) const { return i == p.size() - 1 ? 0 : i + 1; }
    size_t pre(const size_t i) const { return i == 0 ? p.size() - 1 : i - 1; }
    // 回转数 : 返回值第一项表示点是否在多边形边上
    // 对于狭义多边形，回转数为 0 表示点在多边形外，否则点在多边形内
    pair<bool, int> winding(const point<T> &a) const
    {
        int cnt = 0;
        for (size_t i = 0; i < p.size(); ++ i)
        {
            const point<T> u = p[i], v = p[nxt(i)];
            if (abs((a - u) ^ (a - v)) <= eps && (a - u) * (a - v) <= eps) return {true, 0};
            if (abs(u.y - v.y) <= eps) continue;
            const Line uv = {u, v - u};
            if (u.y < v.y - eps && uv.toleft(a) <= 0) continue;
            if (u.y > v.y + eps && uv.toleft(a) >= 0) continue;
            if (u.y < a.y - eps && v.y >= a.y - eps) ++cnt;
            if (u.y >= a.y - eps && v.y < a.y - eps) -- cnt;
        }
        return {false, cnt};
    }
    // 多边形面积的两倍 : 可用于判断点的存储顺序是顺时针或逆时针
    T area() const
    {
        T sum = 0;
        for (size_t i = 0; i < p.size(); ++ i) sum += p[i] ^ p[nxt(i)];
        return sum;
    }
    // 多边形的周长
    long double circ() const
    {
        long double sum = 0;
        for (size_t i = 0; i < p.size(); ++ i) sum += p[i].dis(p[nxt(i)]);
        return sum;
    }
};
using Polygon = polygon<point_t>;
```

### 6、凸多边形

```cpp
template <typename T> struct convex : polygon<T>
{
    // 闵可夫斯基和
    convex operator+(const convex &c) const
    {
        const auto &p = this->p;
        vector<Segment> e1(p.size()), e2(c.p.size()), edge(p.size() + c.p.size());
        vector<point<T>> res;
        res.reserve(p.size() + c.p.size());
        const auto cmp = [](const Segment &u, const Segment &v)
        { return argcmp()(u.b - u.a, v.b - v.a); };
        for (size_t i = 0; i < p.size(); ++ i) e1[i] = {p[i], p[this->nxt(i)]};
        for (size_t i = 0; i < c.p.size(); ++ i) e2[i] = {c.p[i], c.p[c.nxt(i)]};
        rotate(e1.begin(), min_element(e1.begin(), e1.end(), cmp), e1.end());
        rotate(e2.begin(), min_element(e2.begin(), e2.end(), cmp), e2.end());
        merge(e1.begin(), e1.end(), e2.begin(), e2.end(), edge.begin(), cmp);
        const auto check = [](const vector<point<T>> &res, const point<T> &u)
        {
            const auto back1 = res.back(), back2 = *prev(res.end(), 2);
            return (back1 - back2).toleft(u - back1) == 0 && (back1 - back2) * (u - back1) >= -eps;
        };
        auto u = e1[0].a + e2[0].a;
        for (const auto &v : edge)
        {
            while (res.size() > 1 && check(res, u)) res.pop_back();
            res.push_back(u);
            u = u + v.b - v.a;
        }
        if (res.size() > 1 && check(res, res[0])) res.pop_back();
        return {res};
    }

    // 旋转卡壳，func 为更新答案的函数，可以根据题目调整位置
    template <typename F> void rotcaliper(const F &func) const
    {
        const auto &p = this->p;
        const auto area = [](const point<T> &u, const point<T> &v, const point<T> &w)
        { return (w - u) ^ (w - v); };
        for (size_t i = 0, j = 1; i < p.size(); ++ i)
        {
            const auto nxti = this->nxt(i);
            func(p[i], p[nxti], p[j]);
            while (area(p[this->nxt(j)], p[i], p[nxti]) >= area(p[j], p[i], p[nxti]))
            {
                j = this->nxt(j);
                func(p[i], p[nxti], p[j]);
            }
        }
    }
    // 凸多边形的直径的平方
    T diameter2() const
    {
        const auto &p = this->p;
        if (p.size() == 1) return 0;
        if (p.size() == 2) return p[0].dis2(p[1]);
        T ans = 0;
        auto func = [&](const point<T> &u, const point<T> &v, const point<T> &w)
        { ans = max({ans, w.dis2(u), w.dis2(v)}); };
        rotcaliper(func);
        return ans;
    }
    // 判断点是否在凸多边形内，复杂度 O(logn) ：-1 点在多边形边上 | 0 点在多边形外 | 1 点在多边形内
    int is_in(const point<T> &a) const
    {
        const auto &p = this->p;
        if (p.size() == 1) return a == p[0] ? -1 : 0;
        if (p.size() == 2) return segment<T>{p[0], p[1]}.is_on(a) ? -1 : 0;
        if (a == p[0]) return -1;
        if ((p[1] - p[0]).toleft(a - p[0]) == -1 || (p.back() - p[0]).toleft(a - p[0]) == 1) return 0;
        const auto cmp = [&](const Point &u, const Point &v)
        { return (u - p[0]).toleft(v - p[0]) == 1; };
        const size_t i = lower_bound(p.begin() + 1, p.end(), a, cmp) - p.begin();
        if (i == 1) return segment<T>{p[0], p[i]}.is_on(a) ? -1 : 0;
        if (i == p.size() - 1 && segment<T>{p[0], p[i]}.is_on(a)) return -1;
        if (segment<T>{p[i - 1], p[i]}.is_on(a)) return -1;
        return (p[i] - p[i - 1]).toleft(a - p[i - 1]) > 0;
    }
    // 凸多边形关于某一方向的极点，复杂度 O(logn)
    // 参考资料：https://codeforces.com/blog/entry/48868
    template <typename F> size_t extreme(const F &dir) const
    {
        const auto &p = this->p;
        const auto check = [&](const size_t i)
        { return dir(p[i]).toleft(p[this->nxt(i)] - p[i]) >= 0; };
        const auto dir0 = dir(p[0]);
        const auto check0 = check(0);
        if (!check0 && check(p.size() - 1)) return 0;
        const auto cmp = [&](const Point &v)
        {
            const size_t vi = &v - p.data();
            if (vi == 0) return 1;
            const auto checkv = check(vi);
            const auto t = dir0.toleft(v - p[0]);
            if (vi == 1 && checkv == check0 && t == 0) return 1;
            return checkv ^ (checkv == check0 && t <= 0);
        };
        return partition_point(p.begin(), p.end(), cmp) - p.begin();
    }
    // 过凸多边形外一点求凸多边形的切线，返回切点下标，复杂度 O(logn)（必须保证点在多边形外）
    pair<size_t, size_t> tangent(const point<T> &a) const
    {
        const size_t i = extreme([&](const point<T> &u)
                                 { return u - a; });
        const size_t j = extreme([&](const point<T> &u)
                                 { return a - u; });
        return {i, j};
    }
    // 求平行于给定直线的凸多边形的切线，返回切点下标，复杂度 O(logn)
    pair<size_t, size_t> tangent(const line<T> &a) const
    {
        const size_t i = extreme([&](...) { return a.v; });
        const size_t j = extreme([&](...) { return -a.v; });
        return {i, j};
    }
};
using Convex = convex<point_t>;
```

### 7、圆

```cpp
struct Circle
{
    Point c;
    long double r;
    bool operator==(const Circle &a) const { return c == a.c && abs(r - a.r) <= eps; }
    long double circ() const { return 2 * PI * r; } // 周长
    long double area() const { return PI * r * r; } // 面积
    // 点与圆的关系 : -1 圆上 | 0 圆外 | 1 圆内
    int is_in(const Point &p) const
    {
        const long double d = p.dis(c);
        return abs(d - r) <= eps ? -1 : d < r - eps;
    }
    // 直线与圆关系 : 0 相离 | 1 相切 | 2 相交
    int relation(const Line &l) const
    {
        const long double d = l.dis(c);
        if (d > r + eps) return 0;
        if (abs(d - r) <= eps) return 1;
        return 2;
    }
    // 圆与圆关系 : -1 相同 | 0 相离 | 1 外切 | 2 相交 | 3 内切 | 4 内含
    int relation(const Circle &a) const
    {
        if (*this == a) return -1;
        const long double d = c.dis(a.c);
        if (d > r + a.r + eps) return 0;
        if (abs(d - r - a.r) <= eps) return 1;
        if (abs(d - abs(r - a.r)) <= eps) return 3;
        if (d < abs(r - a.r) - eps) return 4;
        return 2;
    }
    // 直线与圆的交点
    vector<Point> inter(const Line &l) const
    {
        const long double d = l.dis(c);
        const Point p = l.proj(c);
        const int t = relation(l);
        if (t == 0) return vector<Point>();
        if (t == 1) return vector<Point>{p};
        const long double k = sqrt(r * r - d * d);
        return vector<Point>{p - (l.v / l.v.len()) * k, p + (l.v / l.v.len()) * k};
    }
    // 圆与圆交点
    vector<Point> inter(const Circle &a) const
    {
        const long double d = c.dis(a.c);
        const int t = relation(a);
        if (t == -1 || t == 0 || t == 4) return vector<Point>();
        Point e = a.c - c;
        e = e / e.len() * r;
        if (t == 1 || t == 3)
        {
            if (r * r + d * d - a.r * a.r >= -eps) return vector<Point>{c + e};
            return vector<Point>{c - e};
        }
        const long double costh = (r * r + d * d - a.r * a.r) / (2 * r * d), sinth = sqrt(1 - costh * costh);
        return vector<Point>{c + e.rot(costh, -sinth), c + e.rot(costh, sinth)};
    }
    // 圆与圆交面积
    long double inter_area(const Circle &a) const
    {
        const long double d = c.dis(a.c);
        const int t = relation(a);
        if (t == -1) return area();
        if (t < 2) return 0;
        if (t > 2) return min(area(), a.area());
        const long double costh1 = (r * r + d * d - a.r * a.r) / (2 * r * d), costh2 = (a.r * a.r + d * d - r * r) / (2 * a.r * d);
        const long double sinth1 = sqrt(1 - costh1 * costh1), sinth2 = sqrt(1 - costh2 * costh2);
        const long double th1 = acos(costh1), th2 = acos(costh2);
        return r * r * (th1 - costh1 * sinth1) + a.r * a.r * (th2 - costh2 * sinth2);
    }
    // 过圆外一点圆的切线
    vector<Line> tangent(const Point &a) const
    {
        const int t = is_in(a);
        if (t == 1) return vector<Line>();
        if (t == -1)
        {
            const Point v = {-(a - c).y, (a - c).x};
            return vector<Line>{{a, v}};
        }
        Point e = a - c;
        e = e / e.len() * r;
        const long double costh = r / c.dis(a), sinth = sqrt(1 - costh * costh);
        const Point t1 = c + e.rot(costh, -sinth), t2 = c + e.rot(costh, sinth);
        return vector<Line>{{a, t1 - a}, {a, t2 - a}};
    }
    // 两圆的公切线
    vector<Line> tangent(const Circle &a) const
    {
        const int t = relation(a);
        vector<Line> lines;
        if (t == -1 || t == 4) return lines;
        if (t == 1 || t == 3)
        {
            const Point p = inter(a)[0], v = {-(a.c - c).y, (a.c - c).x};
            lines.push_back({p, v});
        }
        const long double d = c.dis(a.c);
        const Point e = (a.c - c) / (a.c - c).len();
        if (t <= 2)
        {
            const long double costh = (r - a.r) / d, sinth = sqrt(1 - costh * costh);
            const Point d1 = e.rot(costh, -sinth), d2 = e.rot(costh, sinth);
            const Point u1 = c + d1 * r, u2 = c + d2 * r, v1 = a.c + d1 * a.r, v2 = a.c + d2 * a.r;
            lines.push_back({u1, v1 - u1});
            lines.push_back({u2, v2 - u2});
        }
        if (t == 0)
        {
            const long double costh = (r + a.r) / d, sinth = sqrt(1 - costh * costh);
            const Point d1 = e.rot(costh, -sinth), d2 = e.rot(costh, sinth);
            const Point u1 = c + d1 * r, u2 = c + d2 * r, v1 = a.c - d1 * a.r, v2 = a.c - d2 * a.r;
            lines.push_back({u1, v1 - u1});
            lines.push_back({u2, v2 - u2});
        }
        return lines;
    }
    // 圆的反演
    tuple<int, Circle, Line> inverse(const Line &l) const
    {
        const Circle null_c = {{0.0, 0.0}, 0.0};
        const Line null_l = {{0.0, 0.0}, {0.0, 0.0}};
        if (l.toleft(c) == 0) return {2, null_c, l};
        const Point v = l.toleft(c) == 1 ? Point{l.v.y, -l.v.x} : Point{-l.v.y, l.v.x};
        const long double d = r * r / l.dis(c);
        const Point p = c + v / v.len() * d;
        return {1, {(c + p) / 2, d / 2}, null_l};
    }
    tuple<int, Circle, Line> inverse(const Circle &a) const
    {
        const Circle null_c = {{0.0, 0.0}, 0.0};
        const Line null_l = {{0.0, 0.0}, {0.0, 0.0}};
        const Point v = a.c - c;
        if (a.is_in(c) == -1)
        {
            const long double d = r * r / (a.r + a.r);
            const Point p = c + v / v.len() * d;
            return {2, null_c, {p, {-v.y, v.x}}};
        }
        if (c == a.c) return {1, {c, r * r / a.r}, null_l};
        const long double d1 = r * r / (c.dis(a.c) - a.r), d2 = r * r / (c.dis(a.c) + a.r);
        const Point p = c + v / v.len() * d1, q = c + v / v.len() * d2;
        return {1, {(p + q) / 2, p.dis(q) / 2}, null_l};
    }
};
```

### 8、圆与多边形面积交

```cpp
long double area_inter(const Circle &circ, const Polygon &poly)
{
    const auto cal = [](const Circle &circ, const Point &a, const Point &b)
    {
        if ((a - circ.c).toleft(b - circ.c) == 0) return 0.0l;
        const auto ina = circ.is_in(a), inb = circ.is_in(b);
        const Line ab = {a, b - a};
        if (ina && inb) return ((a - circ.c) ^ (b - circ.c)) / 2;
        if (ina && !inb)
        {
            const auto t = circ.inter(ab);
            const Point p = t.size() == 1 ? t[0] : t[1];
            const long double ans = ((a - circ.c) ^ (p - circ.c)) / 2;
            const long double th = (p - circ.c).ang(b - circ.c);
            const long double d = circ.r * circ.r * th / 2;
            if ((a - circ.c).toleft(b - circ.c) == 1) return ans + d;
            return ans - d;
        }
        if (!ina && inb)
        {
            const Point p = circ.inter(ab)[0];
            const long double ans = ((p - circ.c) ^ (b - circ.c)) / 2;
            const long double th = (a - circ.c).ang(p - circ.c);
            const long double d = circ.r * circ.r * th / 2;
            if ((a - circ.c).toleft(b - circ.c) == 1)
                return ans + d;
            return ans - d;
        }
        const auto p = circ.inter(ab);
        if (p.size() == 2 && Segment{a, b}.dis(circ.c) <= circ.r + eps)
        {
            const long double ans = ((p[0] - circ.c) ^ (p[1] - circ.c)) / 2;
            const long double th1 = (a - circ.c).ang(p[0] - circ.c), th2 = (b - circ.c).ang(p[1] - circ.c);
            const long double d1 = circ.r * circ.r * th1 / 2, d2 = circ.r * circ.r * th2 / 2;
            if ((a - circ.c).toleft(b - circ.c) == 1) return ans + d1 + d2;
            return ans - d1 - d2;
        }
        const long double th = (a - circ.c).ang(b - circ.c);
        if ((a - circ.c).toleft(b - circ.c) == 1) return circ.r * circ.r * th / 2;
        return -circ.r * circ.r * th / 2;
    };
    long double ans = 0;
    for (size_t i = 0; i < poly.p.size(); i++)
    {
        const Point a = poly.p[i], b = poly.p[poly.nxt(i)];
        ans += cal(circ, a, b);
    }
    return ans;
}
```

### 9、点集的凸包

Andrew 算法，复杂度 O(nlogn)

```cpp
Convex convexhull(vector<Point> p)
{
    vector<Point> st;
    if (p.empty()) return Convex{st};
    sort(p.begin(), p.end());
    const auto check = [](const vector<Point> &st, const Point &u)
    {
        const auto back1 = st.back(), back2 = *prev(st.end(), 2);
        return (back1 - back2).toleft(u - back1) <= 0;
    };
    for (const Point &u : p)
    {
        while (st.size() > 1 && check(st, u)) st.pop_back();
        st.push_back(u);
    }
    size_t k = st.size();
    p.pop_back();
    reverse(p.begin(), p.end());
    for (const Point &u : p)
    {
        while (st.size() > k && check(st, u)) st.pop_back();
        st.push_back(u);
    }
    st.pop_back();
    return Convex{st};
}
```

### 10、半平面交

排序增量法，复杂度 O(nlogn)
输入与返回值都是用直线表示的半平面集合

```cpp
vector<Line> halfinter(vector<Line> l, const point_t lim = 1e9)
{
    const auto check = [](const Line &a, const Line &b, const Line &c)
    { return a.toleft(b.inter(c)) < 0; };
    // 无精度误差的方法，但注意取值范围会扩大到三次方
    /*const auto check = [](const Line &a, const Line &b, const Line &c)
    {
        const Point p = a.v * (b.v ^ c.v), q = b.p * (b.v ^ c.v) + b.v * (c.v ^ (b.p - c.p)) - a.p * (b.v ^ c.v);
        return p.toleft(q) < 0;
    };*/
    l.push_back({{-lim, 0}, {0, -1}});
    l.push_back({{0, -lim}, {1, 0}});
    l.push_back({{lim, 0}, {0, 1}});
    l.push_back({{0, lim}, {-1, 0}});
    sort(l.begin(), l.end());
    deque<Line> q;
    for (size_t i = 0; i < l.size(); ++ i)
    {
        if (i > 0 && l[i - 1].v.toleft(l[i].v) == 0 && l[i - 1].v * l[i].v > eps) continue;
        while (q.size() > 1 && check(l[i], q.back(), q[q.size() - 2])) q.pop_back();
        while (q.size() > 1 && check(l[i], q[0], q[1])) q.pop_front();
        if (!q.empty() && q.back().v.toleft(l[i].v) <= 0) return vector<Line>();
        q.push_back(l[i]);
    }
    while (q.size() > 1 && check(q[0], q.back(), q[q.size() - 2])) q.pop_back();
    while (q.size() > 1 && check(q.back(), q[0], q[1])) q.pop_front();
    return vector<Line>(q.begin(), q.end());
}
```

### 11、点集形成的最小最大三角形

极角序扫描线，复杂度 O(n^2logn)
最大三角形问题可以使用凸包与旋转卡壳做到 O(n^2)

```cpp
pair<point_t, point_t> minmax_triangle(const vector<Point> &vec)
{
    if (vec.size() <= 2) return {0, 0};
    vector<pair<int, int> > evt;
    evt.reserve(vec.size() * vec.size());
    point_t maxans = 0, minans = numeric_limits<point_t>::max();
    for (size_t i = 0; i < vec.size(); i++)
    {
        for (size_t j = 0; j < vec.size(); j++)
        {
            if (i == j) continue;
            if (vec[i] == vec[j]) minans = 0;
            else evt.push_back({i, j});
        }
    }
    sort(evt.begin(), evt.end(), [&](const pair<int, int> &u, const pair<int, int> &v)
    {
        const Point du = vec[u.second] - vec[u.first], dv = vec[v.second] - vec[v.first];
        return argcmp() ({du.y, -du.x}, {dv.y, -dv.x}); 
    });
    vector<size_t> vx(vec.size()), pos(vec.size());
    for (size_t i = 0; i < vec.size(); ++ i) vx[i] = i;
    sort(vx.begin(), vx.end(), [&](int x, int y) { return vec[x] < vec[y]; });
    for (size_t i = 0; i < vx.size(); ++ i) pos[vx[i]] = i;
    for (auto [u, v] : evt)
    {
        const size_t i = pos[u], j = pos[v];
        const size_t l = min(i, j), r = max(i, j);
        const Point vecu = vec[u], vecv = vec[v];
        if (l > 0) minans = min(minans, abs((vec[vx[l - 1]] - vecu) ^ (vec[vx[l - 1]] - vecv)));
        if (r < vx.size() - 1) minans = min(minans, abs((vec[vx[r + 1]] - vecu) ^ (vec[vx[r + 1]] - vecv)));
        maxans = max({maxans, abs((vec[vx[0]] - vecu) ^ (vec[vx[0]] - vecv)), abs((vec[vx.back()] - vecu) ^ (vec[vx.back()] - vecv))});
        if (i < j) swap(vx[i], vx[j]), pos[u] = j, pos[v] = i;
    }
    return {minans, maxans};
}
```

### 12、判断多条线段是否有交点

扫描线，复杂度 O(nlogn)

```cpp
bool segs_inter(const vector<Segment> &segs)
{
    if (segs.empty()) return false;
    using seq_t = tuple<point_t, int, Segment>;
    const auto seqcmp = [](const seq_t &u, const seq_t &v)
    {
        const auto [u0, u1, u2] = u;
        const auto [v0, v1, v2] = v;
        if (abs(u0 - v0) <= eps) return make_pair(u1, u2) < make_pair(v1, v2);
        return u0 < v0 - eps;
    };
    vector<seq_t> seq;
    for (auto seg : segs)
    {
        if (seg.a.x > seg.b.x + eps) swap(seg.a, seg.b);
        seq.push_back({seg.a.x, 0, seg});
        seq.push_back({seg.b.x, 1, seg});
    }
    sort(seq.begin(), seq.end(), seqcmp);
    point_t x_now;
    auto cmp = [&](const Segment &u, const Segment &v)
    {
        if (abs(u.a.x - u.b.x) <= eps || abs(v.a.x - v.b.x) <= eps) return u.a.y < v.a.y - eps;
        return ((x_now - u.a.x) * (u.b.y - u.a.y) + u.a.y * (u.b.x - u.a.x)) * (v.b.x - v.a.x) < ((x_now - v.a.x) * (v.b.y - v.a.y) + v.a.y * (v.b.x - v.a.x)) * (u.b.x - u.a.x) - eps;
    };
    multiset<Segment, decltype(cmp)> s{cmp};
    for (const auto [x, o, seg] : seq)
    {
        x_now = x;
        const auto it = s.lower_bound(seg);
        if (o == 0)
        {
            if (it != s.end() && seg.is_inter(*it)) return true;
            if (it != s.begin() && seg.is_inter(*prev(it))) return true;
            s.insert(seg);
        }
        else
        {
            if (next(it) != s.end() && it != s.begin() && (*prev(it)).is_inter(*next(it))) return true;
            s.erase(it);
        }
    }
    return false;
}
```

### 13、多边形面积并

轮廓积分，复杂度 O(n^2logn)，n为边数
ans[i] 表示被至少覆盖了 i+1 次的区域的面积

```cpp
vector<long double> area_union(const vector<Polygon> &polys)
{
    const size_t siz = polys.size();
    vector<vector<pair<Point, Point> > > segs(siz);
    const auto check = [](const Point &u, const Segment &e)
    { return !((u < e.a && u < e.b) || (u > e.a && u > e.b)); };
    auto cut_edge = [&](const Segment &e, const size_t i)
    {
        const Line le{e.a, e.b - e.a};
        vector<pair<Point, int>> evt;
        evt.push_back({e.a, 0});
        evt.push_back({e.b, 0});
        for (size_t j = 0; j < polys.size(); ++ j)
        {
            if (i == j) continue;
            const auto &pj = polys[j];
            for (size_t k = 0; k < pj.p.size(); ++ k)
            {
                const Segment s = {pj.p[k], pj.p[pj.nxt(k)]};
                if (le.toleft(s.a) == 0 && le.toleft(s.b) == 0)
                {
                    evt.push_back({s.a, 0});
                    evt.push_back({s.b, 0});
                }
                else if (s.is_inter(le))
                {
                    const Line ls{s.a, s.b - s.a};
                    const Point u = le.inter(ls);
                    if (le.toleft(s.a) < 0 && le.toleft(s.b) >= 0) evt.push_back({u, -1});
                    else if (le.toleft(s.a) >= 0 && le.toleft(s.b) < 0) evt.push_back({u, 1});
                }
            }
        }
        sort(evt.begin(), evt.end());
        if (e.a > e.b) reverse(evt.begin(), evt.end());
        int sum = 0;
        for (size_t i = 0; i < evt.size(); i++)
        {
            sum += evt[i].second;
            const Point u = evt[i].first, v = evt[i + 1].first;
            if (!(u == v) && check(u, e) && check(v, e)) segs[sum].push_back({u, v});
            if (v == e.b) break;
        }
    };

    for (size_t i = 0; i < polys.size(); ++ i)
    {
        const auto &pi = polys[i];
        for (size_t k = 0; k < pi.p.size(); ++ k)
        {
            const Segment ei = {pi.p[k], pi.p[pi.nxt(k)]};
            cut_edge(ei, i);
        }
    }
    vector<long double> ans(siz);
    for (size_t i = 0; i < siz; i++)
    {
        long double sum = 0;
        sort(segs[i].begin(), segs[i].end());
        int cnt = 0;
        for (size_t j = 0; j < segs[i].size(); j++)
        {
            if (j > 0 && segs[i][j] == segs[i][j - 1]) segs[i + (++cnt)].push_back(segs[i][j]);
            else cnt = 0, sum += segs[i][j].first ^ segs[i][j].second;
        }
        ans[i] = sum / 2;
    }
    return ans;
}
```

### 14、圆面积并

 轮廓积分，复杂度 O(n^2logn)
ans[i] 表示被至少覆盖了 i+1 次的区域的面积

```cpp
vector<long double> area_union(const vector<Circle> &circs)
{
    const size_t siz = circs.size();
    using arc_t = tuple<Point, long double, long double, long double>;
    vector<vector<arc_t>> arcs(siz);
    const auto eq = [](const arc_t &u, const arc_t &v)
    {
        const auto [u1, u2, u3, u4] = u;
        const auto [v1, v2, v3, v4] = v;
        return u1 == v1 && abs(u2 - v2) <= eps && abs(u3 - v3) <= eps && abs(u4 - v4) <= eps;
    };
    auto cut_circ = [&](const Circle &ci, const size_t i)
    {
        vector<pair<long double, int>> evt;
        evt.push_back({-PI, 0});
        evt.push_back({PI, 0});
        int init = 0;
        for (size_t j = 0; j < circs.size(); ++ j)
        {
            if (i == j) continue;
            const Circle &cj = circs[j];
            if (ci.r < cj.r - eps && ci.relation(cj) >= 3) ++ init;
            const auto inters = ci.inter(cj);
            if (inters.size() == 1) evt.push_back({atan2l((inters[0] - ci.c).y, (inters[0] - ci.c).x), 0});
            if (inters.size() == 2)
            {
                const Point dl = inters[0] - ci.c, dr = inters[1] - ci.c;
                long double argl = atan2l(dl.y, dl.x), argr = atan2l(dr.y, dr.x);
                if (abs(argl + PI) <= eps) argl = PI;
                if (abs(argr + PI) <= eps) argr = PI;
                if (argl > argr + eps)
                {
                    evt.push_back({argl, 1});
                    evt.push_back({PI, -1});
                    evt.push_back({-PI, 1});
                    evt.push_back({argr, -1});
                }
                else
                {
                    evt.push_back({argl, 1});
                    evt.push_back({argr, -1});
                }
            }
        }
        sort(evt.begin(), evt.end());
        int sum = init;
        for (size_t i = 0; i < evt.size(); ++ i)
        {
            sum += evt[i].second;
            if (abs(evt[i].first - evt[i + 1].first) > eps) arcs[sum].push_back({ci.c, ci.r, evt[i].first, evt[i + 1].first});
            if (abs(evt[i + 1].first - PI) <= eps) break;
        }
    };
    const auto oint = [](const arc_t &arc)
    {
        const auto [cc, cr, l, r] = arc;
        if (abs(r - l - PI - PI) <= eps) return 2.0l * PI * cr * cr;
        return cr * cr * (r - l) + cc.x * cr * (sin(r) - sin(l)) - cc.y * cr * (cos(r) - cos(l));
    };

    for (size_t i = 0; i < circs.size(); ++ i)
    {
        const auto &ci = circs[i];
        cut_circ(ci, i);
    }
    vector<long double> ans(siz);
    for (size_t i = 0; i < siz; ++ i)
    {
        long double sum = 0;
        sort(arcs[i].begin(), arcs[i].end());
        int cnt = 0;
        for (size_t j = 0; j < arcs[i].size(); ++ j)
        {
            if (j > 0 && eq(arcs[i][j], arcs[i][j - 1])) arcs[i + (++cnt)].push_back(arcs[i][j]);
            else cnt = 0, sum += oint(arcs[i][j]);
        }
        ans[i] = sum / 2;
    }
    return ans;
}
```







# Ⅶ、图论



##  一、拓扑排序

```cpp
// deg是入度，在存图的时候需要录入数据
// A是排序后的数组
vector<vector<int> >g(n + 1);
int deg[N], A[N];
bool toposort(int n)
{
    int cnt = 0;
    queue<int> q;
    for (int i = 1; i <= n; ++i)
    {
        if (deg[i] == 0) q.push(i);
    }
    while (!q.empty())
    {
        int tt = q.front();
        q.pop();
        A[cnt++] = tt;
        for (auto to : g[tt])
        {
            deg[to]--;
            // 出现了新的入度为0的点
            if (deg[to] == 0) q.push(to);
        }
    }
    return cnt == n; // 相等说明没有环，否则说明有环。
}
```


## 二、Dijkstra

单源最短路径 O(n * n)，仅适用于正权图
```cpp
const int N = 1e5 + 10;
const int M = 2e5 + 10;
int front[N], to[M], nxt[M], val[M], dis[N];
bool vis[N];
int cnt = 0, n, m, s;
const int INF = 0x7f7f7f7f7f7f7f7f;
void add(int x, int y, int w)
{
    to[++ cnt] = y;
    val[cnt] = w;
    nxt[cnt] = front[x];
    front[x] = cnt;
}
struct node {int pos, num;};
bool operator < (node a, node b)
{
    if (a.num == b.num) return a.pos < b.pos;
    return a.num > b.num;
}
priority_queue<node> pq;
void Dijkstra()
{
    for(int i = 1; i <= n; ++ i) dis[i] = INF;
    dis[s] = 0ll;
    pq.push({s, 0});
    while(!pq.empty())
    {
        int x = pq.top().pos;
        pq.pop(); 
        if(vis[x]) continue;
        vis[x] = true;
        for(int i = front[x]; i; i = nxt[i])
        {
            int y = to[i];
            if(dis[y] > dis[x] + val[i])
            {
                dis[y] = dis[x] + val[i];
                pq.push({y, dis[y]});
            }
        }
    }
}
```

## 三、Floyd

多源最短路径，时间复杂度 O(n * n * n)，空间复杂度 O(n * n)

```cpp
const int N = 410;
int dp[N][N];
void Floyd()
{
    for (int k = 1; k <= n; ++ k) 
  		for (int x = 1; x <= n; ++ x) 
    		for (int y = 1; y <= n; ++ y) 
      			dp[x][y] = min(dp[x][y], dp[x][k] + dp[k][y]);
}
```





# Ⅷ、博弈论







# Ⅸ、杂项



## 一、小知识点

```cpp
1.
一个 n 位数 (a1a2a3...an) % 9 == (a1 + a2 + ... + an) % 9
123456789(九个数字顺序任意) % 9 == (1 + 2 + ... + 9 % 9)
    
2.
n 所能包含 m 的最大倍数：n - n % m

3.距离
曼哈顿距离：|x1 - x2| + |y1 - y2|
欧几里得距离：两点间距离公式

4.
把 n 个数的区间分为 奇数区间（每个子区间的长度为奇数），满足斐波那契数列。
例：长度为 n 的区间分为奇数区间的方案数为 fib(n - 1) 。

5.debug( )
#define de(x...)                   \
    do {                           \
        std::cout << #x << " -> "; \
        err(x);                    \
    } while (0)                    
void err() {std::cout << std::endl;}
template<class T, class... Ts>
void err(T arg, Ts &... args) 
{std::cout << arg << ' '; err(args...);}

6.快读快写
inline int read()
{
    int x = 0, t = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9')
    {
        if(ch == '-') t = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9')
    {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }
    return x * t;
}
inline void write(int x)
{
    if(x < 0)
    {
        putchar('-');
        x = -x;
    }
    if(x > 9) write(x / 10);
    putchar(x % 10 + '0');
}

7.圆周率
Π == 3.14159265358979323846

8.Mex函数
mex 函数表示一个集合中未出现的最小自然数  ，mex ( { 0 ,  1 ,  3 } ) = 2
int Mex (int a[], int n)
{
    map <int, int> mp;
    for(int i = 1; i <= n; ++ i)
    {
        mp[a[i]] ++ ;
    }
    for(int i = 0; i <= n; ++ i)
    {
        if(mp[i] == 0) return i;
    }
}

9.sqrt函数
int sqrtx(int x)
{
    int k = sqrt(x);
    while (k * k >= x) k --;
    while ((k + 1) * (k + 1) < x) k ++;
    return k;
}

10.乘法函数
const int N = 1e6 + 10;
auto mul = [&] (int a, int b)
{
    if (a == -1 || b == -1) return -1ll;
    if (N / b < a) return -1ll;
    else return a * b;
};

11.带权中位数
题目：有若干个人排列在一条直线的点pi，每个点有a[i]个人，找出一个人使所有人移动到这个人的总距离最小。 
sum[x - 1] == a[1] + a[2] + ... + a[x - 1] < sum / 2
sum[x] == a[1] + a[2] + ... + a[x - 1] + a[x] >= sum / 2 //前缀和的值>=总和的一半时,所有人到x的距离即为答案。
题目：有若干个人排列在一条直线的点pi，每个点有a[i]个人，找出一个人使所有人移动到这个人距离的总平方和最小。
```



## 二、自动取模类

```cpp
const int MOD = 1e9 + 7;
int add(int x, int y)
{
    x += y;
    while (x >= MOD) x -= MOD;
    while (x < 0) x += MOD;
    return x;
}
int sub(int x, int y) {return add(x, MOD - y);}
int mul(int x, int y) {return (x * 1ll * y) % MOD;}
int power(int a, int n)
{
    int ans = 1ll;
    while (n)
    {
        if (n & 1) ans = mul(ans, a);
        a = mul(a, a);
        n >>= 1;
    }
    return ans;
}
int inv(int x) {return power(x, MOD - 2);}
int divide(int x, int y) {return mul(x, inv(y));}
```

